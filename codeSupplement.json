{
  "longest palindromic substring":{"snippet":"Solution.prototype.longestPalindromicSubstring = function(s) {}", "functionName":"longestPalindromicSubstring", "params":[{"param":"valueOf()"}],"returnType":"String"},
  "max points on a line":{"snippet":"Solution.prototype.maxPoints = function(points) {}", "functionName":"maxPoints", "params":[{"param":"valueOf()"}],"returnType":"Number", "extra":"Point"},
  "reverse words in a string":{"snippet":"Solution.prototype.reverseWords = function(s) {}", "functionName":"reverseWords", "params":[{"param":"valueOf()"}], "returnType":"String"},
  "sort list":{"snippet":"Solution.prototype.sortList = function(head) {}", "functionName":"sortList", "params":[{"param":"valueOf()", "realType": "ListNode"}],"returnType":"ListNode","extra":"ListNode"},
  "search insert position":{"snippet":"Solution.prototype.searchInsert = function(A, target) {}", "functionName":"searchInsert", "params":[{"param":"A"},{"param":"target"}],"returnType":"Number"},
  "word search":{"snippet":"Solution.prototype.exist = function (board, word) {}","functionName":"exist", "params": [{"param":"board"},{"param":"word"}], "returnType":"Boolean"},
  "insertion sort list":{"snippet":"Solution.prototype.insertionSortList = function (head) {}", "functionName":"insertionSortList", "params":[{"param":"valueOf()", "realType":"ListNode"}],"returnType": "ListNode","extra":"ListNode", "inPlace":true},
  "largest rectangle in histogram":{"snippet":"Solution.prototype.largestRectangleArea = function (height) {}", "functionName":"largestRectangleArea", "params":[{"param":"valueOf()"}], "returnType": "Number"},
  "evaluate reverse polish notation":{"snippet":"Solution.prototype.evalRPN = function (tokens) {}", "functionName":"evalRPN", "params":[{"param":"valueOf()"}], "returnType":"Number"},
  "binary tree preorder traversal":{"snippet":"Solution.prototype.preorderTraversal = function (root) {}", "functionName":"preorderTraversal", "params":[{"param":"valueOf()", "realType":"TreeNode"}], "returnType":"Array", "extra":"TreeNode"},
  "binary tree postorder traversal":{"snippet":"Solution.prototype.postorderTraversal = function (root) {}", "functionName":"postorderTraversal", "params":[{"param":"valueOf()", "realType":"TreeNode"}], "returnType":"Array","extra":"TreeNode"},
  "binary tree level order traversal":{"snippet":"Solution.prototype.levelOrder = function (root) {}", "functionName":"levelOrder", "params":[{"param":"valueOf()", "realType":"TreeNode"}], "returnType":"Array","extra":"TreeNode"},
  "binary tree level order traversal ii":{"snippet":"Solution.prototype.levelOrderBottom = function(root) {}", "functionName":"levelOrderBottom", "params":[{"param":"valueOf()", "realType":"TreeNode"}], "returnType":"Array","extra":"TreeNode"},
  "binary tree inorder traversal": {"snippet":"Solution.prototype.inorderTraversal = function(root) {}", "functionName":"inorderTraversal", "params":[{"param":"valueOf()", "realType":"TreeNode"}], "returnType":"Array","extra":"TreeNode"},
  "2sum":{"snippet":"Solution.prototype.twoSum = function(numbers, target) {}", "functionName":"twoSum", "params":[{"param":"numbers"},{"param":"target"}], "returnType": "Array"},
  "decode ways":{"snippet":"Solution.prototype.numDecodings = function(s) {}", "functionName":"numDecodings", "params":[{"param":"valueOf()"}], "returnType":"Number"},
  "surrounded regions":{"snippet": "Solution.prototype.solve = function(board) {}", "functionName":"solve", "params":[{"param":"valueOf()"}], "returnType": "Array"},
  "binary tree maximum path sum":{"snippet":"Solution.prototype.maxPathSum = function(root) {}", "functionName":"maxPathSum", "params":[{"param":"valueOf()", "realType":"TreeNode"}], "returnType":"Number","extra":"TreeNode"},
  "sum root to leaf numbers":{"snippet":"Solution.prototype.subNumbers = function(root) {}", "functionName": "subNumbers", "params":[{"param": "valueOf()"}], "returnType":"Number", "extra": "TreeNode"},
  "palindrome partitioning":{"snippet": "Solution.prototype.partition = function(s) {}", "functionName":"partition","params":[{"param":"valueOf()"}],"returnType":"Array", "order": false},
  "palindrome partitioning ii": {"snippet": "Solution.prototype.minCut = function(s) {}", "functionName": "minCut", "params":[{"param": "valueOf()"}], "returnType":"Number"},
  "3sum":{"snippet": "Solution.prototype.threeSum = function(num) {}", "functionName": "threeSum", "params":[{"param":"valueOf()"}], "returnType": "Array", "order":false} ,
  "4sum":{"snippet":"Solution.prototype.fourSum = function(num, target) {}", "functionName":"fourSum", "params":[{"param":"num"}, {"param":"target"}], "returnType":"Array", "order": false},
  "valid parentheses":{"snippet":"Solution.prototype.isValid = function(s) {}", "functionName": "isValid","params":[{"param":"valueOf()"}],"returnType":"Boolean"},
  "remove duplicated from sorted array":{"snippet":"Solution.prototype.removeDuplicates = function(A) {}", "functionName":"removeDuplicates","params":[{"param":"valueOf()"}],"returnType":"Array","inPlace":true},
  "remove element":{"snippet":"Solution.prototype.removeElement = function(A, elem) {}", "functionName": "removeElement","params":[{"param":"A"},{"param":"elem"}],"returnType":"Number"},
  "combination sum":{"snippet":"Solution.prototype.combinationSum = function(candidates, target) {}", "functionName":"combinationSum","params":[{"param":"candidates"},{"param":"target"}],"returnType": "Array","order":false},
  "combination sum ii":{"snippet":"Solution.prototype.combinationSum2 = function(num, target) {}", "functionName":"combinationSum2","params":[{"param":"num"},{"param":"target"}],"returnType": "Array", "order":false},
  "permutations":{"snippet":"Solution.prototype.permute = function(num) {}", "functionName": "permute", "params":[{"param":"valueOf()"}],"returnType": "Array"},
  "rotate image":{"snippet":"Solution.prototype.rotate = function(matrix) {}", "functionName": "rotate","params":[{"param":"valueOf()"}],"returnType":"Array"},
  "maximum subarray":{"snippet":"Solution.prototype.maxSubArray = function(A) {}", "functionName": "maxSubArray", "params":[{"param":"valueOf()"}],"returnType": "Number"},
  "minimum path sum":{"snippet":"Solution.prototype.minPathSum = function(grid) {}", "functionName": "minPathSum", "params":[{"param":"valueOf()"}],"returnType": "Number"},
  "unique binary search trees":{"snippet":"Solution.prototype.numTrees = function(n) {}", "functionName": "numTrees", "params":[{"param":"valueOf()"}], "returnType": "Number"},
  "unique binary search trees ii":{"snippet":"Solution.prototype.generateTrees = function(n) {}", "functionName": "generateTrees", "params":[{"param": "valueOf()"}], "returnType": "TreeNode","extra": "TreeNode"},
  "validate binary search tree":{"snippet":"Solution.prototype.isValidBST = function(root) {}", "functionName": "isValidBST","params":[{"param":"valueOf()","realType": "TreeNode"}],"returnType":"Boolean"},
  "same tree":{"snippet":"Solution.prototype.isSameTree = function(p, q) {}", "functionName": "isSameTree", "params":[{"param": "p","realType": "TreeNode"}],"returnType": "Boolean","extra": "TreeNode"},
  "symmetric tree":{"snippet":"Solution.prototype.isSymmetric = function(root) {}", "functionName": "isSymmetric", "params":[{"param":"valueOf()","realType": "TreeNode"}],"returnType":"Boolean","extra": "TreeNode"},
  "maximum depth of binary tree":{"snippet":"Solution.prototype.maxDepth = function () {}", "functionName": "maxDepth", "params":[{"param": "valueOf()", "realType": "TreeNode"}],"returnType": "Number","extra":"TreeNode"},
  "construct binary tree from preorder and inorder traversal":{"snippet":"Solution.prototype.buildTree = function (preorder, inorder) {}","functionName": "buildTree", "params":[{"param": "preorder"},{"param": "inorder"}],"returnType": "TreeNode","extra": "TreeNode"},
  "construct binary tree from inorder and postorder traversal":{"snippet":"Solution.prototype.buildTree = function (inorder, postorder) {}", "functionName": "buildTree", "params":[{"param": "inorder"},{"param": "postorder"}],"returnType": "TreeNode", "extra": "TreeNode"},
  "flatten binary tree to linked list":{"snippet":"Solution.prototype.flatten = function (root) {}", "functionName": "flatten", "params":[{"param": "valueOf()", "realType": "TreeNode"}], "returnType": "TreeNode","extra": "TreeNode"},
  "path sum":{"snippet":"Solution.prototype.hasPathSum = function(root, sum) {}", "functionName": "hasPathSum", "params":[{"param": "root","realType": "TreeNode"},{"param": "sum"}],"returnType": "Boolean","extra": "TreeNode"},
  "path sum ii":{"snippet":"Solution.prototype.pathSum = function(root, sum) {}", "functionName": "pathSum", "params":[{"param": "root","realType": "TreeNode"},{"param": "sum"}], "returnType":"Array","extra": "TreeNode"},
  "convert sorted list to binary search tree":{"snippet":"Solution.prototype.sortedListToBST = function(head) {}","functionName":"sortedListToBST","params":[{"param":"valueOf()","realType": "ListNode"}],"returnType": "Balanced BST","extra":"ListNode,TreeNode"},
  "convert sorted array to binary search tree":{"snippet":"Solution.prototype.sortedArrayToBST = function(num) {}", "functionName":"sortedArrayToBST","params":[{"param":"valueOf()"}],"returnType":"Balanced BST","extra":"TreeNode"},
  "minimum depth of binary tree":{"snippet":"Solution.prototype.minDepth = function(root) {}", "functionName": "minDepth", "params":[{"param": "valueOf()","realType": "TreeNode"}],"returnType": "Number"},
  "merge sorted array":{"snippet":"Solution.prototype.merge = function(A, m, B, n) {}", "functionName": "merge","params":[{"param":"A"},{"param":"m"},{"param":"B"},{"param":"n"}],"returnType": "Array", "inPlace":true},
  "subsets ii":{"snippet":"Solution.prototype.subsetsWithDup = function(num) {}", "functionName":"subsetsWithDup","params":[{"param":"valueOf()"}],"returnType": "Array", "order":false},
  "search in rotated sorted array ii":{"snippet":"Solution.prototype.search = function(A, target) {}","functionName": "search","params":[{"param":"A"},{"param":"target"}],"returnType": "Boolean"},
  "subsets":{"snippet":"Solution.prototype.subsets = function(S) {}", "functionName": "subsets", "params":[{"param":"valueOf()"}],"returnType":"Array","order":false},
  "partition list":{"snippet":"Solution.prototype.partition = function(head, x) {}", "functionName": "partition", "params":[{"param":"valueOf()"}]},
  "gray code":{"snippet":"Solution.prototype.grayCode = function(n) {}", "functionName": "grayCode", "params":[{"param":"valueOf()"}],"returnType":"Array"},
  "restore ip address":{"snippet":"Solution.prototype.restoreIpAddresses = function(s) {}", "functionName": "restoreIpAddresses", "params":[{"param":"valueOf()"}], "returnType": "Array", "order": false},
  "reverse linked list ii":{"snippet":"Solution.prototype.reverseBetween = function(head, m, n)", "functionName": "reverseBetween", "params":[{"param":"head", "realType": "ListNode"},{"param":"m"},{"param":"n"}], "returnType":"ListNode", "inPlace":true},
  "reverse linked list":{"snippet":"Solution.prototype."},
  "container with most water":{"snippet":"Solution.prototype.maxArea = function(height) {}", "functionName": "maxArea", "params":[{"param":"valueOf()"}], "returnType":"Number"},
  "roman to integer":{"snippet":"Solution.prototype.romanToInt = function(s) {}", "functionName":"romanToInt", "params":[{"param":"valueOf()"}], "returnType":"Number"},
  "search for a range": {"snippet": "Solution.prototype.searchRange = function(s) {}", "functionName": "searchRange", "params":[{"param":"A"},{"param":"target"}], "returnType": "Array"},
  "next permutation" : {"snippet": "Solution.prototype.nextPermutation = function(num) {}", "functionName": "nextPermutation", "params":[{"param":"valueOf()"}], "returnType": "Array", "inPlace": true},
  "largest number": {"snippet":"Solution.prototype.largestNumber = function(num) {}", "functionName": "largestNumber", "params":[{"param":"valueOf()"}], "returnType": "String"},
  "simplify path": {"snippet": "Solution.prototype.simplifyPath =  function(x) {}", "functionName": "simplifyPath", "params": [{"param":"valueOf()"}], "returnType": "String"},
  "permutation sequence": {"snippet": "Solution.prototype.getPermutation = function(n, k) {}", "functionName": "getPermutation", "params":[{"param":"n"},{"param":"k"}], "returnType": "String"},
  "majority element": {"snippet": "Solution.prototype.majorityElement = function(num) {}", "functionName": "majorityElement", "params":[{"param":"valueOf()"}], "returnType":"Number"},
  "reverse linked list iii":{"snippet":"Solution.prototype."},
  "binary tree zigzag level order traversal":{"snippet":"Solution.prototype.zigzagLevelOrder = function (root) {}", "functionName": "zigzagLevelOrder", "params":[{"param":"valueOf()","realType":"TreeNode"}],"returnType":"Array"},
  "edit distance": {"snippet": "Solution.prototype.minDistance = function (word1, word2) {}", "functionName": "minDistance", "params":[{"param":"word1"},{"param":"word2"}], "returnType":"Number"},
  "3sum closest": {"snippet": "Solution.prototype.threeSumClosest = function(num, target) {}", "functionName": "threeSumClosest", "params":[{"param":"num"},{"param":"target"}], "returnType": "Number"},
  "merge two sorted lists": {"snippet":"Solution.prototype.mergeTwoLists(l1, l2) {}", "functionName": "mergeTwoLists", "params":[{"param":"l1", "realType": "ListNode"},{"param":"l2","realType":"ListNode"}], "returnType": "ListNode", "extra": "ListNode"},
  "generate parentheses":{"snippet": "Solution.prototype.generateParenthesis = function(n) {}", "functionName": "generateParenthesis", "params":[{"param": "valueOf()"}], "returnType": "Array"},
  "remove nth node from end of list": {"snippet": "Solution.prototype.removeNthFromEnd = function (head, n) {}", "functionName": "removeNthFromEnd", "params":[{"param":"head", "realType": "ListNode"}, {"param": "n"}], "returnType":"ListNode", "extra": "ListNode"},
  "longest common prefix": {"snippet": "Solution.prototype.longestCommonPrefix = function (strs) {}", "functionName": "longestCommonPrefix","params":[{"param":"valueOf()"}],"returnType": "String"},
  "swap nodes in pairs": {"snippet": "Solution.prototype.swapPairs = function (head) {}", "functionName": "swapPairs", "params":[{"param":"valueOf()","realType":"ListNode"}],"returnType": "ListNode", "extra": "ListNode"},
  "reverse nodes in k-group": {"snippet": "Solution.prototype.reverseKGroup = function (head, k) {}", "functionName": "reverseKGroup","params":[{"param":"head","realType": "ListNode"},{"param": "k"}],"returnType":"ListNode", "extra": "ListNode"},
  "divide two integers": {"snippet": "Solution.prototype.divide = function (dividend, divisor) {}", "functionName": "divide", "params":[{"param":"dividend"}, {"param":"divisor"}], "returnType": "Number"},
  "substring with concatenation of all words": {"snippet":"Solution.prototype.findSubstring = function (S, L) {}", "functionName": "findSubstring", "params":[{"param":"S"},{"param":"L"}], "returnType": "Array"},
  "count and say": {"snippet":"Solution.prototype.countAndSay = function(n) {}", "functionName": "countAndSay", "params":[{"param":"valueOf"}], "returnType": "String"},
  "reverse integer":{"snippet": "Solution.prototype.reverse = function (x) {}", "functionName": "reverse", "params":[{"param":"valueOf()"}], "returnType":"Number"},
  "valid palindrome":{"snippet": "Solution.prototype.isPalindrome = function (s) {}", "functionName": "isPalindrome", "params":[{"param":"s"}], "returnType": "Boolean"},
  "pascal's triangle": {"snippet": "Solution.prototype.generate = function (numRows) {}", "functionName": "generate", "params":[{"param": "valueOf()"}],"returnType":"Array"},
  "pascal's triangle ii": {"snippet": "Solution.prototype.getRow = function (rowIndex) {}", "functionName": "getRow", "params":[{"param": "valueOf()"}], "returnType": "Array"},
  "word break":{"snippet": "Solution.prototype.wordBreak = function (s, dict) {}", "functionName": "wordBreak", "params":[{"param":"s"},{"param":"dict"}], "returnType": "Boolean"},
  "single number":{"snippet": "Solution.prototype.singleNumber = function (A) {}", "functionName": "singleNumber", "params":[{"param":"valueOf()"}], "returnType": "Number"},
  "single number ii": {"snippet": "Solution.prototype.singleNumber = function (A) {}", "functionName": "singleNumber", "params":[{"param": "valueOf()"}], "returnType": "Number"},
  "gas station": {"snippet": "Solution.prototype.canCompleteCircuit = function (gas, cost) {}", "functionName": "canCompleteCircuit", "params":[{"param":"gas"},{"param": "cost"}], "returnType": "Number"},
  "clone graph": {"snippet": "Solution.prototype.cloneGraph = function (node) {}", "functionName": "cloneGraph", "params":[{"param":"valueOf()","realType":"UndirectedGraphNode"}],"returnType": "UndirectedGraphNode","extra":"UndirectedGraphNoe"},
  "word ladder": {"snippet": "Solution.prototype.ladderLength = function (start, end , dict) {}", "functionName": "ladderLength", "params":[{"param":"start"},{"param":"end"},{"param":"dict"}], "returnType": "Number"},
  "search in rotated sorted array": {"snippet": "Solution.prototype.search = function (A, target) {}", "functionName": "search", "params":[{"param":"A"},{"param": "target"}],"returnType": "Number"},
  "median of two sorted arrays": {"snippet": "Solution.prototype.findMedianSortedArrays = function (A, B) {}", "functionName": "findMedianSortedArrays", "params":[{"param":"A"},{"param":"B"}], "returnType": "Number"},
  "regular expression matching": {"snippet": "Solution.prototype.isMatch = function (s, p) {}", "functionName": "isMatch", "params":[{"param":"s"},{"param":"p"}], "returnType": "Boolean"},
  "merge k sorted lists": {"snippet": "Solution.prototype.mergeKLists = function (s) {}", "functionName": "mergeKLists", "params":[{"param":"valueOf()", "realType":"ListNode Array"}], "returnType": "ListNode"},
  "longestValidParentheses" : {"snippet": "Solution.prototype.longestValidParentheses = function (s) {}", "functionName": "longestValidParentheses", "params":[{"param":"valueOf()"}], "returnType": "Number"},
  "sudoku solver": {"snippet": "Solution.prototype.solveSudoku = function (board) {}", "functionName": "solveSudoku", "params":[{"param":"valueOf()"}], "returnType": "Array"},
  "first missing positive": {"snippet": "Solution.prototype.firstMissingPositive = function (A) {}", "functionName": "firstMissingPositive", "params":[{"param": "valueOf()"}], "returnType": "Number"},
  "trapping rain water": {"snippet": "Solution.prototype.trap = function (A) {}", "functionName": "trap", "params":[{"param":"valueOf()"}],"returnType": "Number"},
  "wildcard matching": {"snippet": "Solution.prototype.isMatch = function (s, p ) {}", "functionName": "isMatch", "params":[{"param": "s"}, {"param":"p"}], "returnType": "Boolean"},
  "jump game ii": {"snippet": "Solution.prototype.jump = function(A) {}", "functionName": "jump", "params":[{"param": "valueOf()"}], "returnType": "Number"},
  "permutations ii": {"snippet": "Solution.prototype.permuteUnique = function(num) {}", "functionName": "permuteUnique", "param":[{"param":"valueOf()"}], "returnType": "Array"},
  "n-queens": {"snippet": "Solution.prototype.solveNQueens = function(n) {}", "functionName": "solveNQueens", "params":[{"param": "valueOf()"}], "returnType": "Array"},
  "n-queens ii": {"snippet": "Solution.prototype.totalNQueens = function(n) {}", "functionName": "totalNQueens", "params":[{"param": "valueOf()"}], "returnType": "Number"},
  "merge intervals": {"snippet": "Solution.prototype.merge = function(intervals) {}", "functionName": "merge", "params":[{"param":"valueOf()"}], "returnType": "Array of Interval","extra": "Interval"},
  "insert interval": {"snippet": "Solution.prototype.insert = function(intervals, newInterval) {}", "functionName": "insert", "params": [{"param": "intervals"},{"param":"newInterval"}], "returnType": "Array of Interval", "extra": "Interval"},
  "valid number": {"snippet": "Solution.prototype.isNumber = function(s) {}", "functionName": "isNumber", "params":[{"param":"valueOf()"}], "returnType": "Boolean"},
  "minimum window substring": {"snippet": "Solution.prototype.minWindow = function(S, T) {}", "functionName": "minWindow", "params":[{"param":"S"},{"param":"T"}], "returnType": "String"},
  "text justification": {"snippet": "Solution.prototype.fullJustify = function(words, L) {}", "functionName": "fullJustify","params":[{"param":"words"},{"param":"L"}],"returnType":"Array"},
  "maximalRectangle": {"snippet": "Solution.prototype.maximalRectangle = function(matrix) {}", "functionName": "maximalRectangle","params":[{"param":"valueOf()"}],"returnType": "Number"},
  "scramble string": {"snippet": "Solution.prototype.isScramble = function(s1, s2) {}", "functionName": "isScramble", "params":[{"param": "s1"},{"param":"s2"}], "returnType": "Boolean"},
  "interleaving string": {"snippet": "Solution.prototype.isInterleave = function(s1, s2, s3) {}", "functionName": "isInterleave", "params":[{"param": "s1"},{"param":"s2"},{"param":"s3"}],"returnType": "Boolean"},
  "recover binary search tree": {"snippet": "Solution.prototype.recoverTree = function(root) {}", "functionName": "recoverTree", "params":[{"param":"valueOf()"}],"returnType": "TreeNode"},
  "distinct subsequences": {"snippet": "Solution.prototype.numDistinct = function(S, T) {}", "functionName": "numDistinct", "params":[{"param":"S"},{"param":"T"}],"returnType": "Number"},
  "populating next right pointers in each node ii": {"snippet": "Solution.prototype.connect = function(root) {}", "functionName": "connect", "params":[{"param": "valueOf()"}],"returnType": "TreeLinkNode"},
  "best time to buy and sell stock iii": {"snippet": "Solution.prototype.maxProfit = function(prices) {}", "functionName": "maxProfit", "params":[{"param":"valueOf()"}],"returnType": "Number"},
  "word ladder ii": {"snippet": "Solution.prototype.findLadders = function(start, end, dict) {}", "functionName": "findLadders", "params":[{"param":"start"},{"param": "end"},{"param":"dict"}],"returnType": "Array", "order": "false"},
  "longest consecutive sequence": {"snippet": "Solution.prototype.longestConsecutive = function(num) {}", "functionName": "longestConsecutive","params":[{"param":"valueOf()"}],"returnType": "Number"},
  "candy": {"snippet": "Solution.prototype.candy = function(ratings) {}", "functionName": "candy", "params":[{"param":"valueOf()"}], "returnType":"Number"},
  "copy list with random pinter": {"snippet": "Solution.prototype = function(head) {}", "functionName":"copyRandomList","params":[{"param": "valueOf()"}], "returnType": "RandomListNode", "extra": "RandomListNode"},
  "word break ii": {"snippet": "Solution.prototype.wordBreak = function(s, dict) {}", "functionName": "wordBreak", "params":[{"param":"s"},{"param":"dict"}], "returnType":"Array" },
  "find minimum in rotated sorted array ii": {"snippet": "Solution.prototype.findMin = function(num) {}", "functionName": "findMin", "params":[{"param":"valueOf()"}],"returnType": "Number"},
  "longest substring without repeating characters": {"snippet": "Solution.prototype.lengthOfLongestSubstring = function(s) {}", "functionName": "lengthOfLongestSubstring", "params":[{"param":"valueOf()"}],"returnType": "Number"},
  "add two numbers": {"snippet": "Solution.prototype.addTwoNumbers = function(l1, l2) {}", "functionName": "addTwoNumbers","params":[{"param":"l1","realType": "ListNode"},{"param":"l2","realType":"ListNode"}], "returnType": "ListNode"},
  "letter combination if a phone number":{"snippet": "Solution.prototype.letterCombinations = function (digits) {}", "functionName": "letterCombinations", "params":[{"param": "valueOf()"}],"returnType": "Array"},
  "integer to roman": {"snippet": "Solution.prototype.intToRoman = function(num) {}", "functionName": "intToRoman","params":[{"param":"valueOf()"}],"returnType": "String"},
  "multiply strings": {"snippet": "Solution.prototype.multiply = function(num1, num2) {}", "functionName": "multiply","params":[{"param":"num1"},{"param":"num2"}],"returnType": "String"},
  "jump game": {"snippet": "Solution.prototype.canJump = function (A) {}", "functionName": "canJump", "params":[{"param":"valueOf()"}],"returnType": "Boolean"},
  "spiral matrix": {"snippet": "Solution.prototype.spiralOrder = function (matrix) {}", "functionName": "spiralOrder","params":[{"param":"valueOf()"}],"returnType": "Array"},
  "anagrams": {"snippet": "Solution.prototype.anagrams = function(strs) {}", "functionName": "anagrams", "params":[{"param":"valueOf()"}],"returnType": "Array","order":false},
  "pow(x, n)": {"snippet": "Solution.prototype.pow = function(x, n) {}", "functionName": "pow", "params":[{"param": "x"},{"param": "n"}],"returnType":"Number"},
  "spiral matrix ii": {"snippet": "Solution.prototype.generateMatrix = function(n) {}", "functionName": "generateMatrix","params":[{"param":"valueOf()"}],"returnType":"Array"},
  "rotate list": {"snippet": "Solution.prototype.rotateRight = function(head, n) {}", "functionName": "rotateRight","params":[{"param":"head","realType": "ListNode"},{"param":"n"}],"returnType": "ListNode"},
  "unique paths": {"snippet": "Solution.prototype.uniquePaths = function(m, n) {}", "functionName": "uniquePaths", "params":[{"param":"m"},{"param":"n"}],"returnType": "Number"},
  "unique paths ii" :{"snippet": "Solution.prototype.uniquePathsWithObstacles = function(obstacleGrid) {}", "functionName": "uniquePathsWithObstacles", "params":[{"param": "valueOf()"}], "returnType": "Number"},
  "sqrt(x)": {"snippet": "Solution.prototype.sqrt = function(x) {}","functionName": "sqrt", "params":[{"param":"valueOf()"}],"returnType":"Number"},
  "search a 2d matrix": {"snippet": "Solution.prototype.searchMatrix = function(matrix, target) {}", "functionName": "searchMatrix", "params":[{"param":"matrix"},{"param":"target"}],"returnType":"Boolean"},
  "set matrix zeroes": {"snippet":"Solution.prototype.setZeros = function(matrix) {}", "functionName": "setZeros", "params":[{"param":"valueOf()"}],"returnType":"Array","inPlace":true},
  "sort colors":{"snippet":"Solution.prototype.sortColors = function(A) {}", "functionName": "sortColors", "params":[{"param": "valueOf()"}], "returnType": "Array", "inPlace": true},
  "combinations": {"snippet": "Solution.prototype.combine = function(n, k) {}", "functionName": "combine", "params":[{"param": "n"},{"param": "k"}], "returnType": "Array", "order":false},
  "populating next right pointers in each node" :{"snippet": "Solution.prototype.connect = function(root) {}", "functionName": "connect", "params":[{"param": "valueOf()", "realType": "TreeLinkedNode"}],"returnType": "TreeLinkNode", "extra": "TreeLinkNode"},
  "best time to buy and sell stock ii":{"snippet": "Solution.prototype.maxProfit = function(prices) {}", "functionName": "maxProfit", "params":[{"param": "valueOf()"}], "returnType": "Number"},
  "best time to buy and sell stock":{"snippet":"Solution.prototype.maxProfit = function(prices) {}", "functionName": "maxProfit", "params":[{"param": "valueOf()"}], "returnType": "Number"},
  "linked list cycle":{"snippet":"Solution.prototype.hasCycle = function(head) {}", "functionName": "hasCycle", "params":[{"param": "valueOf()", "realType": "CycleList"}], "returnType": "Boolean", "extra": "ListNode"},
  "linked list cycle ii": {"snippet":"Solution.prototype.detectCycle = function(head) {}", "functionName": "detectCycle", "params":[{"param": "valueOf()", "realType": "CycleList"}], "returnType": "Boolean" ,"extra": "ListNode"},
  "reorder list":{"snippet": "Solution.prototype.reorderList = function(head) {}", "functionName": "reorderList", "params":[{"param": "valueOf()", "realType": "ListNode"}], "returnType": "ListNode", "extra": "ListNode"},
  "maximum product subarray":{"snippet": "Solution.prototype.maxProduct = function(A) {}", "functionName": "maxProduct", "params":[{"param":"valueOf()"}], "returnType": "Number"},
  "find minimum in rotated sorted array":{"snippet": "Solution.prototype.findMin = function(num) {}", "functionName": "findMin", "params":[{"param": "valueOf()"}], "returnType": "Number"},
  "find peak element": {"snippet": "Solution.prototype.findPeakElement = function(num) {}", "functionName": "findPeakElement", "params":[{"param": "valueOf()"}], "returnType": "NUmber"},
  "fraction ro recurring decimal":{"snippet":"Solution.prototype.fractionToDecimal = function(numerator, denominator) {}", "functionName": "fractionToDecimal", "params":[{"param":"numerator"}, {"param": "denominator"}], "returnType": "String"},
  "zigzag conversion":{"snippet":"Solution.prototype.convert = function(s, nRows) {}", "functionName": "convert", "params":[{"param": "s"},{"param": "nRows"}], "returnType": "String"},
  "string to integer ()":{"snippet":"Solution.prototype.atoi = function(str) {}", "functionName": "atoi", "params":[{"param": "valueOf()"}], "returnType": "Number"},
  "palindrome number":{"snippet":"Solution.prototype.isPalindrome = function(x) {}", "functionName": "isPalindrome", "params":[{"param": "valueOf()"}], "returnType": "Boolean"},
  "implement strStr()":{"snippet":"Solution.prototype.isPalindrome = function(x) {}", "functionName": "isPalindrome", "params":[{"param": "valueOf()"}], "returnType": "Boolean"},
  "valid sudoku":{"snippet":"Solution.prototype.isValidSudoku = function(board) {}", "functionName": "isValidSudoku", "params":[{"param": "valueOf()"}], "returnType": "Boolean"},
  "length of last word":{"snippet":"Solution.prototype.lengthOfLastWord = function(board) {}", "functionName": "lengthOfLastWord", "params":[{"param": "valueOf()"}],"returnType": "Number"},
  "add binary":{"snippet":"Solution.prototype.addBinary = function(a, b) {}", "functionName": "addBinary", "params":[{"param": "a"},{"param":"b"}], "returnType": "String"},
  "plus one" :{"snippet":"Solution.prototype.plusOne = function(digits) {}", "functionName": "plusOne", "params":[{"param": "valueOf()"}], "returnType": "Array"},
  "climbing stairs":{"snippet":"Solution.prototype.climbStairs = function(n) {}", "functionName": "climbStairs", "params": [{"param": "valueOf()"}], "returnType": "Number"},
  "remove duplicates from sorted list":{"snippet":"Solution.prototype.deleteDuplicates = function(head) {}", "functionName": "deleteDuplicates", "params":[{"param": "valueOf()", "realType": "ListNode"}], "returnType":"ListNode"},
  "min stack":{"snippet":"Solution.prototype."},
  "compare version numbers":{"snippet":"Solution.prototype.compareVersion = function(version1, version2) {}", "functionName": "compareVersion", "params":[{"param": "version1"},{"param":"version2"}],"returnType": "Number"},
  "excel sheet column number":{"snippet":"Solution.prototype."},
  "majority elements":{"snippet":"Solution.prototype.majorityElement = function(num) {}", "functionNumber": "majorityElement", "params":[{"param": "valueOf()"}], "returnType": "Number"},
  "excel sheet column title":{"snippet":"Solution.prototype."},
  "intersection of two linked lists": {"snippet":"Solution.prototype."},
  "Dungeon game":{"snippet":"Solution.prototype.calculateMinimumHP = function (dungeon) {}", "functionName": "calculateMinimumHap", "params":[{"param":"valueOf()"}],"returnType": "Number"},
  "balanced binary tree":{"snippet":"Solution.prototype.isBalanced = function(root) {}","functionName": "isBalanced","params":[{"param": "valueOf()","realType": "TreeNode"}],"returnType": "Boolean"},
  "lru cache":{"snippet":""},
  "factorial trailing zeros": {"snippet":"Solution.prototype.trailingZeros = function(n) {}", "functionName": "trailingZeros", "params":[{"param":"valueOf()"}], "returnType": "Number"},
  "binary search tree iterator": {},
  "maximum gap":{"snippet":"Solution.prototype.maximumGap = function(num) {}", "functionName": "maximumGap", "params":[{"param": "valueOf()"}], "returnType": "Number"},
  "triangle":{"snippet":"Solution.prototype.minimumTotal = function (triangle) {}", "functionName":"minimumTotal","params":[{"param":"valueOf()"}], "returnType":"Number"}
}